require('dotenv').config();
const http = require('http');
const app = require('./src/app');
const connectDB = require('./src/config/db');

// Connect to DB
connectDB();

const server = http.createServer(app);

// Setup Socket.IO for real-time notifications
const { Server } = require('socket.io');
const io = new Server(server, {
  cors: { origin: '*' },
});

// Pass `io` to our notification socket logic
require('./src/websocket/notificationSocket')(io);

const PORT = process.env.PORT || 4000;
server.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`);
});
{
  "name": "mytask",
  "version": "1.0.0",
  "description": "A Node.js/Express/MongoDB backend for a Jira-like task management system (named 'mytask').",
  "main": "server.js",
  "scripts": {
    "dev": "nodemon server.js",
    "start": "node server.js",
    "test": "echo \"No tests specified\" && exit 0"
  },
  "keywords": [],
  "author": "Your Name",
  "license": "ISC",
  "dependencies": {
    "@sendgrid/mail": "^7.7.0",
    "axios": "^1.4.0",
    "bcrypt": "^5.1.0",
    "dotenv": "^16.1.4",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^7.0.3",
    "nodemailer": "^6.9.1",
    "openai": "^3.2.1",
    "socket.io": "^4.6.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
/**
 * seed.js
 * Script to seed basic data into the "mytask" backend.
 */

require('dotenv').config();
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

// Import your models:
const User = require('./src/models/userModel');
const Team = require('./src/models/teamModel');
const Project = require('./src/models/projectModel');
const Task = require('./src/models/taskModel');
const connectDB = require('./src/config/db');

// Adjust this if you want to *keep* existing data:
const DROP_DATABASE = true; // or false if you only want to add

async function seed() {
    try {
        console.log('[Seed] Connecting to database...');
        await connectDB();

        if (DROP_DATABASE) {
            console.log('[Seed] Dropping existing collections...');
            // Drop all relevant collections; if they don't exist, no error is thrown
            await mongoose.connection.db.dropCollection('users').catch(() => {});
            await mongoose.connection.db.dropCollection('teams').catch(() => {});
            await mongoose.connection.db.dropCollection('projects').catch(() => {});
            await mongoose.connection.db.dropCollection('tasks').catch(() => {});
            // Add more if needed (comments, sprints, etc.)
        }

        console.log('[Seed] Creating sample users...');
        // Create a superadmin user
        const superadminPassword = await bcrypt.hash('Supersecret123', 10);
        const superadminUser = new User({
            name: 'Superadmin',
            email: 'superadmin@mytask.com',
            passwordHash: superadminPassword,
        });
        await superadminUser.save();

        // Create a normal user
        const userPassword = await bcrypt.hash('Userpass123', 10);
        const normalUser = new User({
            name: 'John Doe',
            email: 'john@mytask.com',
            passwordHash: userPassword,
        });
        await normalUser.save();

        console.log('[Seed] Creating a sample team...');
        const team = new Team({
            name: 'Alpha Team',
            description: 'This is the Alpha Team!',
            ownerUserId: superadminUser._id,
            members: [superadminUser._id, normalUser._id],
        });
        await team.save();

        // Link the team references back to the users
        superadminUser.teams.push(team._id);
        normalUser.teams.push(team._id);

        // For demonstration, superadmin "owns" the team
        superadminUser.ownedTeams.push(team._id);

        await superadminUser.save();
        await normalUser.save();

        console.log('[Seed] Creating a sample project...');
        const project = new Project({
            name: 'Project Phoenix',
            description: 'A sample project for demonstration.',
            teamIds: [team._id],
            ownerUserId: superadminUser._id,
        });
        await project.save();

        // Link the project references back to the users
        superadminUser.ownedProjects.push(project._id);
        normalUser.assignedProjects.push(project._id);

        // Optional: set RBAC roles
        // e.g., superadminUser is "Manager" on this project, normalUser is "Developer"
        superadminUser.projectRoles.set(project._id.toString(), 'Superadmin');
        normalUser.projectRoles.set(project._id.toString(), 'Developer');

        await superadminUser.save();
        await normalUser.save();

        console.log('[Seed] Creating sample tasks...');
        const task1 = new Task({
            title: 'Setup CI/CD',
            description: 'Configure GitHub Actions pipeline for the project.',
            projectId: project._id,
            assignedTo: normalUser._id, // assigned to John
            status: 'ToDo',
            priority: 'High',
        });
        await task1.save();

        const task2 = new Task({
            title: 'Implement Login Page',
            description: 'Create the frontend login page and connect to backend.',
            projectId: project._id,
            assignedTo: normalUser._id,
            status: 'ToDo',
            priority: 'Medium',
        });
        await task2.save();

        // Link tasks to project
        project.tasks.push(task1._id, task2._id);
        await project.save();

        // Also reflect these tasks on the user
        normalUser.assignedTasks.push(task1._id, task2._id);
        await normalUser.save();

        console.log('[Seed] Seeding completed successfully!');
    } catch (error) {
        console.error('[Seed] Error seeding data:', error);
    } finally {
        mongoose.connection.close();
    }
}

seed();// Basic role-based example. Extend as needed.
module.exports = (requiredRole) => {
  return (req, res, next) => {
    const user = req.user;
    if (!user) {
      return res.status(403).json({ message: 'No user context' });
    }
    // Example: if user name is "Superadmin" or user has certain role
    if (user.name === 'Superadmin') {
      return next();
    }
    // Fallback: user doesn't have the required role
    return res.status(403).json({ message: 'Forbidden: Insufficient role' });
  };
};
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');

module.exports = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(401).json({ message: 'No token provided' });

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id);
    if (!user) return res.status(401).json({ message: 'Invalid token or user' });

    req.user = user;
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Unauthorized' });
  }
};
module.exports = (io) => {
  io.on('connection', (socket) => {
    console.log('Socket connected:', socket.id);

    // Example: client subscribes to notifications
    socket.on('subscribeToNotifications', (userId) => {
      socket.join(`user_${userId}`);
      console.log(`User ${userId} joined room user_${userId}`);
    });

    // Example: client unsubscribes
    socket.on('unsubscribeFromNotifications', (userId) => {
      socket.leave(`user_${userId}`);
      console.log(`User ${userId} left room user_${userId}`);
    });
  });

  // Provide a helper to broadcast messages
  global.sendUserNotification = (userId, notificationData) => {
    io.to(`user_${userId}`).emit('notification', notificationData);
  };
};
const mongoose = require('mongoose');

async function connectDB() {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('Connected to MongoDB Atlas');
  } catch (error) {
    console.error('MongoDB connection failed:', error);
    process.exit(1);
  }
}

module.exports = connectDB;
const AuditLog = require('../models/auditLogModel');

exports.logAction = async (userId, action, entity, entityId, changes, ipAddress) => {
  try {
    const logEntry = new AuditLog({
      userId,
      action,
      entity,
      entityId,
      changes,
      ipAddress
    });
    await logEntry.save();
  } catch (error) {
    console.error('Audit Log Error:', error);
  }
};
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
  host: process.env.EMAIL_SMTP_HOST,
  port: process.env.EMAIL_SMTP_PORT,
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS
  }
});

exports.sendEmail = async (to, subject, html) => {
  await transporter.sendMail({
    from: 'noreply@yourapp.com',
    to,
    subject,
    html
  });
};
const mongoose = require('mongoose');
const { Schema } = mongoose;

const subscriptionSchema = new Schema({
  name: { type: String, required: true },
  billingCycle: { type: String, enum: ['Monthly', 'Yearly'], required: true },
  features: [{ type: String }],
  userLimit: { type: Number, default: 10 },
  projectLimit: { type: Number, default: 5 },
  status: {
    type: String,
    enum: ['Active', 'Expired', 'Canceled'],
    default: 'Active'
  }
});

module.exports = mongoose.model('Subscription', subscriptionSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const sprintSchema = new Schema({
  name: { type: String, required: true },
  description: { type: String },
  projectId: { type: Schema.Types.ObjectId, ref: 'Project', required: true },
  startDate: { type: Date },
  endDate: { type: Date },
  taskIds: [{ type: Schema.Types.ObjectId, ref: 'Task' }],
  progressPercentage: { type: Number, default: 0 }
});

module.exports = mongoose.model('Sprint', sprintSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const labelSchema = new Schema({
  name: { type: String, required: true },
  color: { type: String, default: '#000000' }
});

module.exports = mongoose.model('Label', labelSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const AISummarySchema = new Schema({
  timestamp: { type: Date, default: Date.now },
  content: { type: String }
});

const LayoutViewSchema = new Schema({
  layoutId: { type: Schema.Types.ObjectId },
  sections: [
    {
      name: String,
      visible: Boolean,
      position: Number
    }
  ]
});

const userSchema = new Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  passwordHash: { type: String, required: true },
  teams: [{ type: Schema.Types.ObjectId, ref: 'Team' }],
  ownedTeams: [{ type: Schema.Types.ObjectId, ref: 'Team' }],
  assignedProjects: [{ type: Schema.Types.ObjectId, ref: 'Project' }],
  ownedProjects: [{ type: Schema.Types.ObjectId, ref: 'Project' }],
  currentTask: { type: Schema.Types.ObjectId, ref: 'Task' },
  assignedTasks: [{ type: Schema.Types.ObjectId, ref: 'Task' }],
  recentlyCompletedTasks: [{ type: Schema.Types.ObjectId, ref: 'Task' }],
  projectRoles: {
    // projectId -> role
    type: Map,
    of: {
      type: String,
      enum: ['Developer', 'Manager', 'QA', 'Client', 'Superadmin']
    },
    default: {}
  },
  summaries: {
    // projectId -> [AISummarySchema]
    type: Map,
    of: [AISummarySchema]
  },
  projectViews: {
    // projectId -> LayoutViewSchema
    type: Map,
    of: LayoutViewSchema
  },
  mfaEnabled: { type: Boolean, default: false },
  mfaSecret: { type: String },
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('User', userSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const commentSchema = new Schema({
  taskId: { type: Schema.Types.ObjectId, ref: 'Task', required: true },
  userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  message: { type: String, required: true },
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Comment', commentSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const ganttDataSchema = new Schema({
  taskId: { type: Schema.Types.ObjectId, ref: 'Task' },
  title: { type: String },
  startDate: { type: Date },
  endDate: { type: Date }
});

const reportSchema = new Schema({
  projectId: { type: Schema.Types.ObjectId, ref: 'Project', required: true },
  type: {
    type: String,
    enum: ['Daily', 'Weekly', 'Sprint', 'Overall'],
    required: true
  },
  createdAt: { type: Date, default: Date.now },
  aiSummary: { type: String },
  tasks: [{ type: Schema.Types.ObjectId, ref: 'Task' }],
  ganttData: [ganttDataSchema]
});

module.exports = mongoose.model('Report', reportSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const projectSchema = new Schema({
  name: { type: String, required: true },
  description: { type: String },
  teamIds: [{ type: Schema.Types.ObjectId, ref: 'Team' }],
  ownerUserId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  tasks: [{ type: Schema.Types.ObjectId, ref: 'Task' }],
  currentSprint: { type: Schema.Types.ObjectId, ref: 'Sprint' },
  settings: {
    statuses: { type: [String], default: ['ToDo', 'Doing', 'Testing', 'Done'] },
    priorities: { type: [String], default: ['High', 'Medium', 'Low'] },
    roles: { type: [String], default: ['Developer', 'Manager', 'QA', 'Client', 'Superadmin'] }
  }
});

module.exports = mongoose.model('Project', projectSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const auditLogSchema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'User' },
  action: { type: String },
  entity: { type: String }, // e.g., 'User', 'Project', 'Task'
  entityId: { type: Schema.Types.ObjectId },
  changes: { type: Schema.Types.Mixed },
  timestamp: { type: Date, default: Date.now },
  ipAddress: { type: String }
});

module.exports = mongoose.model('AuditLog', auditLogSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const teamSchema = new Schema({
  name: { type: String, required: true },
  description: { type: String },
  members: [{ type: Schema.Types.ObjectId, ref: 'User' }],
  ownerUserId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  settings: {
    roles: { type: [String], default: ['Developer', 'Manager', 'QA', 'Client', 'Superadmin'] },
    permissions: { type: Schema.Types.Mixed }
  }
});

module.exports = mongoose.model('Team', teamSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const notificationSchema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  message: { type: String, required: true },
  url: { type: String },
  isRead: { type: Boolean, default: false },
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Notification', notificationSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const attachmentSchema = new Schema({
  taskId: { type: Schema.Types.ObjectId, ref: 'Task', required: true },
  fileName: { type: String, required: true },
  fileUrl: { type: String, required: true },
  uploadedBy: { type: Schema.Types.ObjectId, ref: 'User' },
  uploadedAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Attachment', attachmentSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const taskSchema = new Schema({
  title: { type: String, required: true },
  description: { type: String },
  status: {
    type: String,
    default: 'ToDo',
    enum: ['ToDo', 'Doing', 'Testing', 'Done']
  },
  priority: {
    type: String,
    default: 'Medium',
    enum: ['High', 'Medium', 'Low']
  },
  assignedTo: { type: Schema.Types.ObjectId, ref: 'User' },
  projectId: { type: Schema.Types.ObjectId, ref: 'Project', required: true },
  sprintId: { type: Schema.Types.ObjectId, ref: 'Sprint' },
  dueDate: { type: Date },
  labels: [{ type: Schema.Types.ObjectId, ref: 'Label' }],
  attachments: [{ type: Schema.Types.ObjectId, ref: 'Attachment' }],
  comments: [{ type: Schema.Types.ObjectId, ref: 'Comment' }],
  history: [{ type: Schema.Types.ObjectId, ref: 'TaskHistory' }],
  estimatedTime: { type: Number, default: 0 },
  loggedTime: { type: Number, default: 0 },
  startDate: { type: Date },
  endDate: { type: Date },
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Task', taskSchema);
const mongoose = require('mongoose');
const { Schema } = mongoose;

const taskHistorySchema = new Schema({
  taskId: { type: Schema.Types.ObjectId, ref: 'Task', required: true },
  changedBy: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  change: { type: String },
  timestamp: { type: Date, default: Date.now }
});

module.exports = mongoose.model('TaskHistory', taskHistorySchema);
const Project = require('../models/projectModel');
const { logAction } = require('../utils/logger');
const { generateSummary } = require('../services/aiService');

// Create a new project
exports.createProject = async (req, res) => {
  try {
    const { name, description, teamIds } = req.body;
    const project = new Project({
      name,
      description,
      teamIds,
      ownerUserId: req.user._id
    });
    await project.save();

    await logAction(
      req.user._id,
      'CREATE_PROJECT',
      'Project',
      project._id,
      { name, description, teamIds },
      req.ip
    );

    res.status(201).json({ project });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get all projects
exports.getAllProjects = async (req, res) => {
  try {
    const projects = await Project.find().populate('teamIds');
    res.json(projects);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Update a project (with AI summary example)
exports.updateProject = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description } = req.body;

    const project = await Project.findById(id);
    if (!project) {
      return res.status(404).json({ message: 'Project not found' });
    }

    // Basic check: if user is not owner, block
    if (String(project.ownerUserId) !== String(req.user._id)) {
      return res.status(403).json({ message: 'Not authorized to update project' });
    }

    // Update fields
    project.name = name || project.name;
    project.description = description || project.description;
    await project.save();

    await logAction(
      req.user._id,
      'UPDATE_PROJECT',
      'Project',
      project._id,
      { name, description },
      req.ip
    );

    // AI summary if description changed
    if (description) {
      const summary = await generateSummary(description);
      console.log('AI Summary:', summary);
    }

    res.json({ project });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');
const { logAction } = require('../utils/logger');
const { sendEmail } = require('../utils/email');

// Register a new user
exports.registerUser = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    let existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const passwordHash = await bcrypt.hash(password, 10);
    const user = new User({ name, email, passwordHash });
    await user.save();

    await logAction(
      user._id,
      'CREATE_USER',
      'User',
      user._id,
      { name, email },
      req.ip
    );

    // Optional: send welcome email
    // await sendEmail(email, 'Welcome!', `<h1>Hi ${name}, thanks for registering!</h1>`);

    res.status(201).json({ message: 'User registered', userId: user._id });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Login user
exports.loginUser = async (req, res) => {
  try {
    const { email, password /* mfaToken */ } = req.body;
    const user = await User.findOne({ email });
    if (!user) return res.status(401).json({ message: 'Invalid credentials' });

    const match = await bcrypt.compare(password, user.passwordHash);
    if (!match) return res.status(401).json({ message: 'Invalid credentials' });

    // If MFA enabled, verify TOTP here (speakeasy)

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {
      expiresIn: '8h'
    });

    res.json({ token, userId: user._id });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get current user profile
exports.getProfile = async (req, res) => {
  try {
    // user is attached to req in auth middleware
    const user = await User.findById(req.user._id).select('-passwordHash');
    res.json({ user });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
// src/controllers/teamController.js
const Team = require('../models/teamModel');
const User = require('../models/userModel');
const { logAction } = require('../utils/logger');

exports.createTeam = async (req, res) => {
    try {
        const { name, description } = req.body;
        const team = new Team({
            name,
            description,
            ownerUserId: req.user._id,
            members: [req.user._id]
        });
        await team.save();

        // Also update user who created the team
        await User.findByIdAndUpdate(req.user._id, {
            $push: { ownedTeams: team._id, teams: team._id }
        });

        await logAction(req.user._id, 'CREATE_TEAM', 'Team', team._id, { name }, req.ip);

        res.status(201).json({ team });
    } catch (error) {
        console.error('Create Team Error:', error);
        res.status(500).json({ message: 'Failed to create team' });
    }
};

exports.getAllTeams = async (req, res) => {
    try {
        // Possibly filter by membership: find all teams in which req.user is a member
        // If you want: Team.find({ members: req.user._id })
        const teams = await Team.find().populate('members', 'name email');
        res.json({ teams });
    } catch (error) {
        console.error('Get All Teams Error:', error);
        res.status(500).json({ message: 'Failed to retrieve teams' });
    }
};

exports.getTeamById = async (req, res) => {
    try {
        const { teamId } = req.params;
        const team = await Team.findById(teamId).populate('members', 'name email');
        if (!team) {
            return res.status(404).json({ message: 'Team not found' });
        }
        res.json({ team });
    } catch (error) {
        console.error('Get Team By ID Error:', error);
        res.status(500).json({ message: 'Failed to retrieve team' });
    }
};

exports.updateTeam = async (req, res) => {
    try {
        const { teamId } = req.params;
        const { name, description } = req.body;
        const team = await Team.findById(teamId);
        if (!team) {
            return res.status(404).json({ message: 'Team not found' });
        }

        // Check if current user is the owner
        if (String(team.ownerUserId) !== String(req.user._id)) {
            return res.status(403).json({ message: 'Not authorized to update this team' });
        }

        if (name) team.name = name;
        if (description) team.description = description;
        await team.save();

        await logAction(req.user._id, 'UPDATE_TEAM', 'Team', team._id, { name }, req.ip);

        res.json({ team });
    } catch (error) {
        console.error('Update Team Error:', error);
        res.status(500).json({ message: 'Failed to update team' });
    }
};

exports.deleteTeam = async (req, res) => {
    try {
        const { teamId } = req.params;
        const team = await Team.findById(teamId);
        if (!team) {
            return res.status(404).json({ message: 'Team not found' });
        }

        // Check if current user is the owner
        if (String(team.ownerUserId) !== String(req.user._id)) {
            return res.status(403).json({ message: 'Not authorized to delete this team' });
        }

        // Remove references from users
        await User.updateMany(
            { _id: { $in: team.members } },
            { $pull: { teams: team._id } }
        );

        await team.remove();

        await logAction(req.user._id, 'DELETE_TEAM', 'Team', teamId, {}, req.ip);

        res.json({ message: 'Team deleted' });
    } catch (error) {
        console.error('Delete Team Error:', error);
        res.status(500).json({ message: 'Failed to delete team' });
    }
};

exports.addMember = async (req, res) => {
    try {
        const { teamId } = req.params;
        const { userId } = req.body;

        const team = await Team.findById(teamId);
        if (!team) return res.status(404).json({ message: 'Team not found' });

        // Optional: only allow team owner or manager to add members
        if (String(team.ownerUserId) !== String(req.user._id)) {
            return res.status(403).json({ message: 'Not authorized' });
        }

        // Add user to team
        if (!team.members.includes(userId)) {
            team.members.push(userId);
            await team.save();

            // Also update user document
            await User.findByIdAndUpdate(userId, {
                $push: { teams: team._id }
            });
        }

        await logAction(
            req.user._id,
            'ADD_MEMBER',
            'Team',
            teamId,
            { newMember: userId },
            req.ip
        );

        res.json({ team });
    } catch (error) {
        console.error('Add Member Error:', error);
        res.status(500).json({ message: 'Failed to add member' });
    }
};

exports.removeMember = async (req, res) => {
    try {
        const { teamId, memberId } = req.params;

        const team = await Team.findById(teamId);
        if (!team) return res.status(404).json({ message: 'Team not found' });

        if (String(team.ownerUserId) !== String(req.user._id)) {
            return res.status(403).json({ message: 'Not authorized' });
        }

        // Remove user from team
        await Team.findByIdAndUpdate(teamId, {
            $pull: { members: memberId }
        });

        // Also remove team from user's doc
        await User.findByIdAndUpdate(memberId, {
            $pull: { teams: teamId }
        });

        await logAction(
            req.user._id,
            'REMOVE_MEMBER',
            'Team',
            teamId,
            { removedMember: memberId },
            req.ip
        );

        res.json({ message: 'Member removed from team' });
    } catch (error) {
        console.error('Remove Member Error:', error);
        res.status(500).json({ message: 'Failed to remove member' });
    }
};// src/controllers/taskController.js
const Task = require('../models/taskModel');
const Project = require('../models/projectModel');
const { logAction } = require('../utils/logger');
const { createNotification } = require('../services/notificationService');

/**
 * Create a new task
 */
exports.createTask = async (req, res) => {
    try {
        const { title, description, projectId, assignedTo, priority, status } = req.body;

        // Optional: verify the user is allowed to create tasks in this project
        // e.g., check if req.user is part of the project or a manager

        const task = new Task({
            title,
            description,
            projectId,
            assignedTo,
            priority,
            status
        });
        await task.save();

        await logAction(
            req.user._id,
            'CREATE_TASK',
            'Task',
            task._id,
            { title, projectId },
            req.ip
        );

        // You can optionally update the Project to push this task into its `tasks` array
        await Project.findByIdAndUpdate(projectId, {
            $push: { tasks: task._id }
        });

        // Notify the user who was assigned (if assignedTo is set)
        if (assignedTo) {
            await createNotification(
                assignedTo,
                `You have been assigned a new task: ${task.title}`,
                `/tasks/${task._id}`
            );
        }

        res.status(201).json({ task });
    } catch (error) {
        console.error('Create Task Error:', error);
        res.status(500).json({ message: 'Failed to create task' });
    }
};

/**
 * Get all tasks (optionally filter by project, by user, etc.)
 */
exports.getAllTasks = async (req, res) => {
    try {
        // You can parse query params: /api/tasks?projectId=xxx or /api/tasks?assignedTo=xxx
        const { projectId, assignedTo } = req.query;
        const query = {};

        if (projectId) {
            query.projectId = projectId;
        }
        if (assignedTo) {
            query.assignedTo = assignedTo;
        }

        const tasks = await Task.find(query)
            .populate('assignedTo', 'name email')
            .populate('projectId', 'name');

        res.json({ tasks });
    } catch (error) {
        console.error('Get All Tasks Error:', error);
        res.status(500).json({ message: 'Failed to retrieve tasks' });
    }
};

/**
 * Get a task by ID
 */
exports.getTaskById = async (req, res) => {
    try {
        const { taskId } = req.params;
        const task = await Task.findById(taskId)
            .populate('assignedTo', 'name email')
            .populate('projectId', 'name');

        if (!task) {
            return res.status(404).json({ message: 'Task not found' });
        }

        res.json({ task });
    } catch (error) {
        console.error('Get Task By ID Error:', error);
        res.status(500).json({ message: 'Failed to retrieve task' });
    }
};

/**
 * Update a task
 */
exports.updateTask = async (req, res) => {
    try {
        const { taskId } = req.params;
        const { title, description, status, priority, assignedTo, dueDate } = req.body;

        const task = await Task.findById(taskId);
        if (!task) {
            return res.status(404).json({ message: 'Task not found' });
        }

        // Update fields
        if (title) task.title = title;
        if (description) task.description = description;
        if (status) task.status = status;
        if (priority) task.priority = priority;
        if (assignedTo) {
            // if assignedTo changes from oldUser to newUser, you can notify both
            // oldUser: "Task unassigned"
            // newUser: "Task assigned to you"
            task.assignedTo = assignedTo;
        }
        if (dueDate) task.dueDate = dueDate;

        await task.save();

        await logAction(
            req.user._id,
            'UPDATE_TASK',
            'Task',
            task._id,
            { title, status, assignedTo },
            req.ip
        );

        // Possibly notify the assigned user
        if (assignedTo) {
            await createNotification(
                assignedTo,
                `Task updated: ${task.title}`,
                `/tasks/${task._id}`
            );
        }

        res.json({ task });
    } catch (error) {
        console.error('Update Task Error:', error);
        res.status(500).json({ message: 'Failed to update task' });
    }
};

/**
 * Delete a task
 */
exports.deleteTask = async (req, res) => {
    try {
        const { taskId } = req.params;
        const task = await Task.findById(taskId);

        if (!task) {
            return res.status(404).json({ message: 'Task not found' });
        }

        // Optional: verify authorization, e.g. only the project manager or the owner can remove the task

        await Task.findByIdAndDelete(taskId);

        // Also remove from project's tasks array
        await Project.findByIdAndUpdate(task.projectId, {
            $pull: { tasks: task._id }
        });

        await logAction(
            req.user._id,
            'DELETE_TASK',
            'Task',
            task._id,
            { title: task.title },
            req.ip
        );

        res.json({ message: 'Task deleted' });
    } catch (error) {
        console.error('Delete Task Error:', error);
        res.status(500).json({ message: 'Failed to delete task' });
    }
};

/**
 * Assign a task to a user (alternate approach if you want a dedicated route)
 */
exports.assignTask = async (req, res) => {
    try {
        const { taskId } = req.params;
        const { userId } = req.body; // user to assign

        const task = await Task.findById(taskId);
        if (!task) {
            return res.status(404).json({ message: 'Task not found' });
        }

        // Perform any necessary checks (e.g., is user in the same project/team?)
        task.assignedTo = userId;
        await task.save();

        await logAction(
            req.user._id,
            'ASSIGN_TASK',
            'Task',
            task._id,
            { assignedTo: userId },
            req.ip
        );

        // Notify the assigned user
        await createNotification(
            userId,
            `You have been assigned a task: ${task.title}`,
            `/tasks/${task._id}`
        );

        res.json({ task });
    } catch (error) {
        console.error('Assign Task Error:', error);
        res.status(500).json({ message: 'Failed to assign task' });
    }
};// src/controllers/sprintController.js
const Sprint = require('../models/sprintModel');
const Project = require('../models/projectModel');
const Task = require('../models/taskModel');
const { logAction } = require('../utils/logger');
const { createNotification } = require('../services/notificationService');

/**
 * Create a new Sprint for a given project
 */
exports.createSprint = async (req, res) => {
    try {
        const { projectId } = req.params; // from route: /api/projects/:projectId/sprints
        const { name, description, startDate, endDate } = req.body;

        // Check if the project exists
        const project = await Project.findById(projectId);
        if (!project) {
            return res.status(404).json({ message: 'Project not found' });
        }

        // Optional: Check user permissions - only project owner or "Manager" role can create sprints
        if (String(project.ownerUserId) !== String(req.user._id)) {
            // or check if req.user has appropriate role for this project
            // e.g. if (req.user.projectRoles.get(projectId) !== 'Manager') ...
            return res.status(403).json({ message: 'Not authorized to create a sprint' });
        }

        // Create the sprint
        const sprint = new Sprint({
            name,
            description,
            projectId: project._id,
            startDate,
            endDate,
            taskIds: []
        });

        await sprint.save();

        // Log action (optional)
        await logAction(
            req.user._id,
            'CREATE_SPRINT',
            'Sprint',
            sprint._id,
            { name, projectId },
            req.ip
        );

        // Optionally notify the project owner, or project members
        // e.g. createNotification(ownerUserId, `A new sprint (${sprint.name}) was created.`, ...);

        res.status(201).json({ sprint });
    } catch (error) {
        console.error('Create Sprint Error:', error);
        res.status(500).json({ message: 'Failed to create sprint' });
    }
};

/**
 * Get all sprints for a specific project
 */
exports.getSprintsForProject = async (req, res) => {
    try {
        const { projectId } = req.params;

        // Optional: check if user can view this project

        const sprints = await Sprint.find({ projectId }).populate('taskIds');
        res.json({ sprints });
    } catch (error) {
        console.error('Get Sprints For Project Error:', error);
        res.status(500).json({ message: 'Failed to retrieve sprints' });
    }
};

/**
 * Get a specific sprint by ID
 */
exports.getSprintById = async (req, res) => {
    try {
        const { sprintId } = req.params;
        const sprint = await Sprint.findById(sprintId).populate('taskIds');
        if (!sprint) {
            return res.status(404).json({ message: 'Sprint not found' });
        }
        res.json({ sprint });
    } catch (error) {
        console.error('Get Sprint By ID Error:', error);
        res.status(500).json({ message: 'Failed to retrieve sprint' });
    }
};

/**
 * Update an existing sprint
 */
exports.updateSprint = async (req, res) => {
    try {
        const { sprintId } = req.params;
        const { name, description, startDate, endDate } = req.body;

        const sprint = await Sprint.findById(sprintId);
        if (!sprint) {
            return res.status(404).json({ message: 'Sprint not found' });
        }

        // Optional: Check user permission - must be project owner or manager
        // We can do this by loading the parent project, comparing ownership or roles:
        const project = await Project.findById(sprint.projectId);
        if (!project) {
            return res.status(404).json({ message: 'Parent project not found' });
        }
        if (String(project.ownerUserId) !== String(req.user._id)) {
            return res.status(403).json({ message: 'Not authorized to update sprint' });
        }

        if (name) sprint.name = name;
        if (description) sprint.description = description;
        if (startDate) sprint.startDate = startDate;
        if (endDate) sprint.endDate = endDate;

        await sprint.save();

        await logAction(
            req.user._id,
            'UPDATE_SPRINT',
            'Sprint',
            sprint._id,
            { name, startDate, endDate },
            req.ip
        );

        res.json({ sprint });
    } catch (error) {
        console.error('Update Sprint Error:', error);
        res.status(500).json({ message: 'Failed to update sprint' });
    }
};

/**
 * Delete a sprint
 */
exports.deleteSprint = async (req, res) => {
    try {
        const { sprintId } = req.params;

        const sprint = await Sprint.findById(sprintId);
        if (!sprint) {
            return res.status(404).json({ message: 'Sprint not found' });
        }

        // Optional: Check user permission
        const project = await Project.findById(sprint.projectId);
        if (!project) {
            return res.status(404).json({ message: 'Parent project not found' });
        }
        if (String(project.ownerUserId) !== String(req.user._id)) {
            return res.status(403).json({ message: 'Not authorized to delete sprint' });
        }

        // Before removing the sprint, you may want to handle tasks
        // e.g., set their sprintId to null or move them to the backlog
        await Task.updateMany(
            { _id: { $in: sprint.taskIds } },
            { $unset: { sprintId: '' } }
        );

        await sprint.remove();

        await logAction(req.user._id, 'DELETE_SPRINT', 'Sprint', sprintId, {}, req.ip);

        res.json({ message: 'Sprint deleted' });
    } catch (error) {
        console.error('Delete Sprint Error:', error);
        res.status(500).json({ message: 'Failed to delete sprint' });
    }
};

/**
 * Add a task to a sprint
 */
exports.addTaskToSprint = async (req, res) => {
    try {
        const { sprintId, taskId } = req.params;

        const sprint = await Sprint.findById(sprintId);
        if (!sprint) {
            return res.status(404).json({ message: 'Sprint not found' });
        }

        // Check project ownership/roles again
        const project = await Project.findById(sprint.projectId);
        if (!project) {
            return res.status(404).json({ message: 'Project not found' });
        }
        if (String(project.ownerUserId) !== String(req.user._id)) {
            return res.status(403).json({ message: 'Not authorized' });
        }

        // Find the task to ensure it belongs to the same project
        const task = await Task.findById(taskId);
        if (!task) {
            return res.status(404).json({ message: 'Task not found' });
        }
        if (String(task.projectId) !== String(project._id)) {
            return res.status(400).json({ message: 'Task does not belong to this project' });
        }

        // Add the task to the sprint if not already present
        if (!sprint.taskIds.includes(taskId)) {
            sprint.taskIds.push(taskId);
            await sprint.save();
        }

        // Also update the task to indicate which sprint it's in
        task.sprintId = sprint._id;
        await task.save();

        await logAction(
            req.user._id,
            'ADD_TASK_TO_SPRINT',
            'Sprint',
            sprint._id,
            { taskId },
            req.ip
        );

        // Optionally notify the user assigned to the task
        if (task.assignedTo) {
            await createNotification(
                task.assignedTo,
                `Your task "${task.title}" was added to sprint: ${sprint.name}`,
                `/sprints/${sprint._id}`
            );
        }

        res.json({ sprint });
    } catch (error) {
        console.error('Add Task to Sprint Error:', error);
        res.status(500).json({ message: 'Failed to add task to sprint' });
    }
};

/**
 * Remove a task from a sprint
 */
exports.removeTaskFromSprint = async (req, res) => {
    try {
        const { sprintId, taskId } = req.params;

        const sprint = await Sprint.findById(sprintId);
        if (!sprint) {
            return res.status(404).json({ message: 'Sprint not found' });
        }

        // Check project ownership/roles
        const project = await Project.findById(sprint.projectId);
        if (!project) {
            return res.status(404).json({ message: 'Project not found' });
        }
        if (String(project.ownerUserId) !== String(req.user._id)) {
            return res.status(403).json({ message: 'Not authorized' });
        }

        // Remove taskId from sprint
        sprint.taskIds = sprint.taskIds.filter((tId) => String(tId) !== String(taskId));
        await sprint.save();

        // Update the taskâ€™s sprintId to null (or remove it)
        await Task.findByIdAndUpdate(taskId, { $unset: { sprintId: '' } });

        await logAction(
            req.user._id,
            'REMOVE_TASK_FROM_SPRINT',
            'Sprint',
            sprint._id,
            { taskId },
            req.ip
        );

        res.json({ sprint });
    } catch (error) {
        console.error('Remove Task from Sprint Error:', error);
        res.status(500).json({ message: 'Failed to remove task from sprint' });
    }
};const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');
const {
  createProject,
  getAllProjects,
  updateProject
} = require('../controllers/projectController');

// All these routes are protected by JWT auth
router.post('/', auth, createProject);
router.get('/', auth, getAllProjects);
router.put('/:id', auth, updateProject);

module.exports = router;
// src/routes/sprintRoutes.js
const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');
const {
    createSprint,
    getSprintsForProject,
    getSprintById,
    updateSprint,
    deleteSprint,
    addTaskToSprint,
    removeTaskFromSprint
} = require('../controllers/sprintController');

// CREATE a new Sprint for a project
router.post('/projects/:projectId/sprints', auth, createSprint);

// GET all sprints for a project
router.get('/projects/:projectId/sprints', auth, getSprintsForProject);

// GET one sprint by ID
router.get('/:sprintId', auth, getSprintById);

// UPDATE sprint
router.put('/:sprintId', auth, updateSprint);

// DELETE sprint
router.delete('/:sprintId', auth, deleteSprint);

// ADD a task to a sprint
router.post('/:sprintId/tasks/:taskId', auth, addTaskToSprint);

// REMOVE a task from a sprint
router.delete('/:sprintId/tasks/:taskId', auth, removeTaskFromSprint);

module.exports = router;const express = require('express');
const router = express.Router();
const { registerUser, loginUser, getProfile } = require('../controllers/userController');
const auth = require('../middleware/auth');

// Public endpoints
router.post('/register', registerUser);
router.post('/login', loginUser);

// Protected endpoints
router.get('/profile', auth, getProfile);

module.exports = router;
// src/routes/teamRoutes.js
const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');
const {
    createTeam,
    getAllTeams,
    getTeamById,
    updateTeam,
    deleteTeam,
    addMember,
    removeMember
} = require('../controllers/teamController');

router.post('/', auth, createTeam);
router.get('/', auth, getAllTeams);
router.get('/:teamId', auth, getTeamById);
router.put('/:teamId', auth, updateTeam);
router.delete('/:teamId', auth, deleteTeam);

// Member management
router.post('/:teamId/members', auth, addMember);
router.delete('/:teamId/members/:memberId', auth, removeMember);

module.exports = router;// src/routes/taskRoutes.js
const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');
const {
    createTask,
    getAllTasks,
    getTaskById,
    updateTask,
    deleteTask,
    assignTask
} = require('../controllers/taskController');

/**
 * @route   POST /api/tasks
 * @desc    Create a new task
 */
router.post('/', auth, createTask);

/**
 * @route   GET /api/tasks
 * @desc    Get all tasks (optionally filtered by project or user)
 */
router.get('/', auth, getAllTasks);

/**
 * @route   GET /api/tasks/:taskId
 * @desc    Get task details by ID
 */
router.get('/:taskId', auth, getTaskById);

/**
 * @route   PUT /api/tasks/:taskId
 * @desc    Update an existing task
 */
router.put('/:taskId', auth, updateTask);

/**
 * @route   DELETE /api/tasks/:taskId
 * @desc    Delete a task
 */
router.delete('/:taskId', auth, deleteTask);

/**
 * @route   POST /api/tasks/:taskId/assign
 * @desc    Assign a task to a user
 */
router.post('/:taskId/assign', auth, assignTask);

module.exports = router;// src/app.js
const express = require('express');
const cors = require('cors');

const userRoutes = require('./routes/userRoutes');
const projectRoutes = require('./routes/projectRoutes');
const taskRoutes = require('./routes/taskRoutes');
const teamRoutes = require('./routes/teamRoutes');
const sprintRoutes = require('./routes/sprintRoutes'); // Import your new routes

const app = express();

app.use(cors());
app.use(express.json());

// Mount routes
app.use('/api/users', userRoutes);
app.use('/api/projects', projectRoutes);
app.use('/api/tasks', taskRoutes);
app.use('/api/teams', teamRoutes);
app.use('/api/sprints', sprintRoutes); // Sprint routes

app.get('/', (req, res) => {
  res.send('mytask Backend is running...');
});

module.exports = app;const { Configuration, OpenAIApi } = require('openai');

const configuration = new Configuration({
  apiKey: process.env.OPENAI_API_KEY
});
const openai = new OpenAIApi(configuration);

exports.generateSummary = async (text) => {
  try {
    const response = await openai.createChatCompletion({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'You are an assistant that summarizes project updates.'
        },
        {
          role: 'user',
          content: `Summarize this project update: ${text}`
        }
      ]
    });
    return response.data.choices[0].message.content.trim();
  } catch (error) {
    console.error('OpenAI error:', error);
    return 'Unable to generate summary at this time.';
  }
};
const Notification = require('../models/notificationModel');

// Basic function to create a notification entry
async function createNotification(userId, message, url) {
  const notification = new Notification({ userId, message, url });
  await notification.save();
  return notification;
}

module.exports = {
  createNotification
};
